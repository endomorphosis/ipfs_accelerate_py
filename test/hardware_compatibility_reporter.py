#!/usr/bin/env python
"""
Hardware Compatibility Error Reporting System

This module provides a centralized system for collecting, analyzing, and reporting
hardware compatibility errors across different components of the IPFS Accelerate Python Framework.
It integrates with hardware_detection, model_family_classifier, ResourcePool, and other components
to provide comprehensive error reporting and recommendations.

Usage:
    python hardware_compatibility_reporter.py --collect-all
    python hardware_compatibility_reporter.py --test-hardware
    python hardware_compatibility_reporter.py --check-model bert-base-uncased
    python hardware_compatibility_reporter.py --matrix
"""

import os
import sys
import json
import logging
import argparse
from datetime import datetime
import traceback
from typing import Dict, List, Any, Optional, Union, Tuple

# Configure logging
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Default output directory for reports
DEFAULT_OUTPUT_DIR = os.path.join(os.path.dirname(__file__), "hardware_compatibility_reports")

class HardwareCompatibilityReporter:
    """
    Central class for collecting, analyzing, and reporting hardware compatibility errors.
    Integrates with various components to provide a consolidated view of compatibility issues.
    """
    
    def __init__(self, output_dir: str = DEFAULT_OUTPUT_DIR, debug: bool = False):
        """
        Initialize the hardware compatibility reporter.
        
        Args:
            output_dir: Directory where reports will be saved
            debug: Enable debug logging
        """
        self.errors = []
        self.output_dir = output_dir
        self.error_registry = {
            "cuda": [], "rocm": [], "mps": [], "openvino": [], 
            "webnn": [], "webgpu": [], "qualcomm": [], "cpu": []
        }
        
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Set up logging
        if debug:
            logger.setLevel(logging.DEBUG)
            
        # Track models tested
        self.models_tested = set()
        
        # Hardware detection status
        self.hardware_detection_available = False
        self.model_classifier_available = False
        self.model_integration_available = False
        self.resource_pool_available = False
        
        # Initialize error counts
        self.error_counts = {
            "critical": 0,
            "error": 0, 
            "warning": 0,
            "info": 0
        }
        
        # Error type recommendations
        self.recommendation_templates = self._get_recommendation_templates()
        
        logger.info(f"Initialized HardwareCompatibilityReporter with output directory: {output_dir}")
        
    def check_components(self) -> Dict[str, bool]:
        """
        Check which components are available for error collection.
        Checks file existence before attempting imports.
        
        Returns:
            Dictionary with component availability status
        """
        import os.path
        
        # Get the directory of the current file
        current_dir = os.path.dirname(os.path.abspath(__file__))
        
        # Check for resource_pool.py
        resource_pool_path = os.path.join(current_dir, "resource_pool.py")
        self.resource_pool_available = os.path.exists(resource_pool_path)
        
        # Check for hardware_detection.py
        hardware_detection_path = os.path.join(current_dir, "hardware_detection.py")
        self.hardware_detection_available = os.path.exists(hardware_detection_path)
        
        # Check for model_family_classifier.py
        model_classifier_path = os.path.join(current_dir, "model_family_classifier.py")
        self.model_classifier_available = os.path.exists(model_classifier_path)
        
        # Check for hardware_model_integration.py
        integration_path = os.path.join(current_dir, "hardware_model_integration.py")
        self.model_integration_available = os.path.exists(integration_path)
        
        # Log component availability
        logger.info(f"ResourcePool available: {self.resource_pool_available}")
        logger.info(f"HardwareDetection available: {self.hardware_detection_available}")
        logger.info(f"ModelFamilyClassifier available: {self.model_classifier_available}")
        logger.info(f"HardwareModelIntegration available: {self.model_integration_available}")
        
        return {
            "resource_pool": self.resource_pool_available,
            "hardware_detection": self.hardware_detection_available,
            "model_family_classifier": self.model_classifier_available,
            "hardware_model_integration": self.model_integration_available
        }
        
    def collect_hardware_detection_errors(self) -> List[Dict[str, Any]]:
        """
        Collect errors from the HardwareDetector component.
        Handles gracefully if the component is not available.
        
        Returns:
            List of collected errors
        """
        if not self.hardware_detection_available:
            logger.warning("HardwareDetection component not available, skipping error collection")
            return []
            
        collected_errors = []
        
        try:
            # Import hardware detector
            from hardware_detection import HardwareDetector
            detector = HardwareDetector()
            
            # Get hardware detection errors
            hw_errors = detector.get_errors() if hasattr(detector, "get_errors") else {}
            
            for hw_type, error in hw_errors.items():
                error_data = self.add_error(
                    hardware_type=hw_type,
                    error_type="detection_failure",
                    severity="error",
                    message=str(error),
                    component="hardware_detection"
                )
                collected_errors.append(error_data)
                
            # Check for hardware initialization errors
            try:
                # Get comprehensive hardware info with error checking
                hw_info = detector.detect_hardware_with_comprehensive_checks()
                
                # Check for specific hardware initialization errors
                if "errors" in hw_info:
                    for hw_type, error_msg in hw_info["errors"].items():
                        if hw_type not in hw_errors:  # Avoid duplicate errors
                            error_data = self.add_error(
                                hardware_type=hw_type,
                                error_type="initialization_failed",
                                severity="warning",
                                message=str(error_msg),
                                component="hardware_detection"
                            )
                            collected_errors.append(error_data)
            except Exception as e:
                logger.warning(f"Error getting comprehensive hardware info: {e}")
                error_data = self.add_error(
                    hardware_type="unknown",
                    error_type="detection_exception",
                    severity="error",
                    message=str(e),
                    component="hardware_detection",
                    traceback=traceback.format_exc()
                )
                collected_errors.append(error_data)
                
            logger.info(f"Collected {len(collected_errors)} errors from HardwareDetector")
            return collected_errors
            
        except ImportError as e:
            logger.error(f"Could not import HardwareDetector: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="import_error",
                severity="critical",
                message=f"Could not import HardwareDetector: {e}",
                component="hardware_compatibility_reporter"
            )
            collected_errors.append(error_data)
            return collected_errors
            
        except Exception as e:
            logger.error(f"Error collecting hardware detection errors: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="collection_error",
                severity="error",
                message=f"Error collecting hardware detection errors: {e}",
                component="hardware_compatibility_reporter",
                traceback=traceback.format_exc()
            )
            collected_errors.append(error_data)
            return collected_errors
            
    def collect_model_integration_errors(self, model_name: str) -> List[Dict[str, Any]]:
        """
        Collect errors from the hardware_model_integration component for a specific model.
        
        Args:
            model_name: Name of the model to check for integration errors
            
        Returns:
            List of collected errors
        """
        if not self.model_integration_available:
            logger.warning("HardwareModelIntegration component not available, skipping error collection")
            return []
            
        collected_errors = []
        self.models_tested.add(model_name)
        
        try:
            # Import integration module
            from hardware_model_integration import integrate_hardware_and_model
            
            # Check integration for the model
            integration_result = integrate_hardware_and_model(model_name=model_name)
            
            # Check for errors in the integration result
            if "error" in integration_result:
                error_data = self.add_error(
                    hardware_type=integration_result.get("device", "unknown"),
                    error_type="integration_error",
                    severity="error",
                    message=integration_result["error"],
                    component="hardware_model_integration",
                    model_name=model_name
                )
                collected_errors.append(error_data)
                
            # Check for hardware compatibility errors
            if "compatibility_errors" in integration_result:
                for hw_type, error_msg in integration_result["compatibility_errors"].items():
                    error_data = self.add_error(
                        hardware_type=hw_type,
                        error_type="compatibility_error",
                        severity="warning",
                        message=error_msg,
                        component="hardware_model_integration",
                        model_name=model_name
                    )
                    collected_errors.append(error_data)
                    
            # Also check for classification errors or warnings
            if "classification_errors" in integration_result:
                for error_msg in integration_result["classification_errors"]:
                    error_data = self.add_error(
                        hardware_type="all",
                        error_type="classification_error",
                        severity="warning",
                        message=error_msg,
                        component="model_family_classifier",
                        model_name=model_name
                    )
                    collected_errors.append(error_data)
                    
            logger.info(f"Collected {len(collected_errors)} errors for model {model_name} from integration")
            return collected_errors
            
        except ImportError as e:
            logger.error(f"Could not import hardware_model_integration: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="import_error",
                severity="critical",
                message=f"Could not import hardware_model_integration: {e}",
                component="hardware_compatibility_reporter"
            )
            collected_errors.append(error_data)
            return collected_errors
            
        except Exception as e:
            logger.error(f"Error collecting model integration errors: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="collection_error",
                severity="error",
                message=f"Error collecting model integration errors: {e}",
                component="hardware_compatibility_reporter",
                traceback=traceback.format_exc(),
                model_name=model_name
            )
            collected_errors.append(error_data)
            return collected_errors
    
    def collect_resource_pool_errors(self) -> List[Dict[str, Any]]:
        """
        Collect errors from the ResourcePool stats and error log.
        
        Returns:
            List of collected errors
        """
        if not self.resource_pool_available:
            logger.warning("ResourcePool component not available, skipping error collection")
            return []
            
        collected_errors = []
        
        try:
            # Import resource pool
            from resource_pool import get_global_resource_pool
            pool = get_global_resource_pool()
            
            # Get resource pool stats
            stats = pool.get_stats()
            
            # Check for CUDA memory pressure
            cuda_memory = stats.get("cuda_memory", {})
            if cuda_memory and cuda_memory.get("device_count", 0) > 0:
                for device in cuda_memory.get("devices", []):
                    device_id = device.get("id", 0)
                    percent_used = device.get("percent_used", 0)
                    
                    # Check for high memory usage
                    if percent_used > 90:
                        error_data = self.add_error(
                            hardware_type="cuda",
                            error_type="memory_pressure",
                            severity="warning",
                            message=f"CUDA memory usage is high: {percent_used:.1f}% on device {device_id}",
                            component="resource_pool"
                        )
                        collected_errors.append(error_data)
                        
            # Check for system memory pressure
            system_memory = stats.get("system_memory", {})
            if system_memory and system_memory.get("percent_used", 0) > 90:
                error_data = self.add_error(
                    hardware_type="cpu",
                    error_type="memory_pressure",
                    severity="warning",
                    message=f"System memory usage is high: {system_memory.get('percent_used')}%",
                    component="resource_pool"
                )
                collected_errors.append(error_data)
                
            # Check if low memory mode is active
            if stats.get("low_memory_mode", False):
                error_data = self.add_error(
                    hardware_type="all",
                    error_type="low_memory_mode",
                    severity="info",
                    message="System is operating in low memory mode",
                    component="resource_pool"
                )
                collected_errors.append(error_data)
                
            # Check for resource pool errors
            for key, value in stats.get("errors", {}).items():
                error_data = self.add_error(
                    hardware_type="all",
                    error_type="resource_error",
                    severity="error",
                    message=f"ResourcePool error for {key}: {value}",
                    component="resource_pool"
                )
                collected_errors.append(error_data)
                
            logger.info(f"Collected {len(collected_errors)} errors from ResourcePool")
            return collected_errors
            
        except ImportError as e:
            logger.error(f"Could not import ResourcePool: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="import_error",
                severity="critical",
                message=f"Could not import ResourcePool: {e}",
                component="hardware_compatibility_reporter"
            )
            collected_errors.append(error_data)
            return collected_errors
            
        except Exception as e:
            logger.error(f"Error collecting ResourcePool errors: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="collection_error",
                severity="error",
                message=f"Error collecting ResourcePool errors: {e}",
                component="hardware_compatibility_reporter",
                traceback=traceback.format_exc()
            )
            collected_errors.append(error_data)
            return collected_errors
            
    def collect_compatibility_test_errors(self, test_models: List[str] = None) -> List[Dict[str, Any]]:
        """
        Collect errors by running compatibility tests on models.
        
        Args:
            test_models: List of model names to test, or None to use default test set
            
        Returns:
            List of collected errors
        """
        from_components = []
        models = test_models or ["bert-base-uncased", "t5-small", "vit-base-patch16-224"]
        
        for model in models:
            # Add model to tested models set
            self.models_tested.add(model)
            
            # Skip if we don't have required components
            if not self.model_integration_available:
                logger.warning("Skipping compatibility test - model integration not available")
                error_data = self.add_error(
                    hardware_type="all",
                    error_type="missing_component",
                    severity="warning",
                    message="Cannot run compatibility tests: model integration component not available",
                    component="hardware_compatibility_reporter"
                )
                from_components.append(error_data)
                continue
                
            try:
                # Import integration module
                from hardware_model_integration import integrate_hardware_and_model
                
                # Run test for this model
                logger.info(f"Testing compatibility for model: {model}")
                result = integrate_hardware_and_model(model_name=model)
                
                # Check for errors in the integration result
                if "error" in result:
                    error_data = self.add_error(
                        hardware_type=result.get("device", "unknown"),
                        error_type="compatibility_test_error",
                        severity="error",
                        message=result["error"],
                        component="hardware_compatibility_reporter",
                        model_name=model
                    )
                    from_components.append(error_data)
                    
                # Check for hardware compatibility errors
                if "compatibility_errors" in result:
                    for hw_type, error_msg in result["compatibility_errors"].items():
                        error_data = self.add_error(
                            hardware_type=hw_type,
                            error_type="compatibility_error",
                            severity="warning",
                            message=error_msg,
                            component="hardware_compatibility_reporter",
                            model_name=model
                        )
                        from_components.append(error_data)
                        
                # Check memory requirements vs available memory
                if "memory_requirements" in result and "available_memory" in result:
                    req_memory = result["memory_requirements"].get("peak", 0)
                    avail_memory = result["available_memory"].get(result.get("device", "cpu"), 0)
                    
                    if req_memory > avail_memory:
                        error_data = self.add_error(
                            hardware_type=result.get("device", "unknown"),
                            error_type="insufficient_memory",
                            severity="warning",
                            message=f"Model requires {req_memory}MB but only {avail_memory}MB available",
                            component="hardware_compatibility_reporter",
                            model_name=model
                        )
                        from_components.append(error_data)
                        
            except Exception as e:
                logger.error(f"Error testing compatibility for model {model}: {e}")
                error_data = self.add_error(
                    hardware_type="all",
                    error_type="test_error",
                    severity="error",
                    message=f"Error testing compatibility for model {model}: {e}",
                    component="hardware_compatibility_reporter",
                    traceback=traceback.format_exc(),
                    model_name=model
                )
                from_components.append(error_data)
                
        logger.info(f"Collected {len(from_components)} errors from compatibility tests")
        return from_components
        
    def test_full_hardware_stack(self) -> List[Dict[str, Any]]:
        """
        Test the full hardware stack by checking for issues with all hardware types.
        
        Returns:
            List of collected errors
        """
        if not self.hardware_detection_available:
            logger.warning("Cannot test hardware stack - hardware detection not available")
            error_data = self.add_error(
                hardware_type="all",
                error_type="missing_component",
                severity="warning",
                message="Cannot test hardware stack: hardware detection component not available",
                component="hardware_compatibility_reporter"
            )
            return [error_data]
            
        collected_errors = []
        
        try:
            # Import hardware detector with comprehensive checks
            from hardware_detection import detect_hardware_with_comprehensive_checks
            
            # Get comprehensive hardware info
            hw_info = detect_hardware_with_comprehensive_checks()
            
            # Check for specific hardware types and test each
            hardware_types = ["cuda", "rocm", "mps", "openvino", "webnn", "webgpu", "qualcomm", "cpu"]
            
            for hw_type in hardware_types:
                # Skip if hardware not present
                if not hw_info.get(hw_type, False):
                    logger.debug(f"Hardware {hw_type} not available, skipping test")
                    continue
                    
                logger.info(f"Testing hardware: {hw_type}")
                
                # Test hardware functionality
                if hw_type == "cuda" and hw_info.get("cuda"):
                    self._test_cuda_functionality(collected_errors)
                elif hw_type == "mps" and hw_info.get("mps"):
                    self._test_mps_functionality(collected_errors)
                elif hw_type == "openvino" and hw_info.get("openvino"):
                    self._test_openvino_functionality(collected_errors)
                elif hw_type == "webnn" and hw_info.get("webnn"):
                    self._test_webnn_functionality(collected_errors)
                elif hw_type == "webgpu" and hw_info.get("webgpu"):
                    self._test_webgpu_functionality(collected_errors)
                    
            # Check for specific errors in hardware info
            if "errors" in hw_info:
                for hw_type, error_msg in hw_info["errors"].items():
                    error_data = self.add_error(
                        hardware_type=hw_type,
                        error_type="hardware_test_error",
                        severity="error",
                        message=error_msg,
                        component="hardware_compatibility_reporter"
                    )
                    collected_errors.append(error_data)
                    
            logger.info(f"Collected {len(collected_errors)} errors from hardware stack tests")
            return collected_errors
            
        except ImportError as e:
            logger.error(f"Could not import hardware_detection: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="import_error",
                severity="critical",
                message=f"Could not import hardware_detection for stack testing: {e}",
                component="hardware_compatibility_reporter"
            )
            return [error_data]
            
        except Exception as e:
            logger.error(f"Error testing hardware stack: {e}")
            error_data = self.add_error(
                hardware_type="all",
                error_type="test_error",
                severity="error",
                message=f"Error testing hardware stack: {e}",
                component="hardware_compatibility_reporter",
                traceback=traceback.format_exc()
            )
            return [error_data]
            
    def _test_cuda_functionality(self, collected_errors):
        """Test CUDA functionality and collect errors"""
        try:
            import torch
            
            # Try to create a tensor on CUDA
            try:
                x = torch.ones(10, 10).cuda()
                # Try a simple operation
                y = x + x
                logger.debug("CUDA functionality test passed")
            except RuntimeError as e:
                error_data = self.add_error(
                    hardware_type="cuda",
                    error_type="runtime_error",
                    severity="error",
                    message=f"CUDA functionality test failed: {e}",
                    component="hardware_compatibility_reporter"
                )
                collected_errors.append(error_data)
                
        except ImportError as e:
            error_data = self.add_error(
                hardware_type="cuda",
                error_type="import_error",
                severity="warning",
                message=f"Could not import PyTorch for CUDA testing: {e}",
                component="hardware_compatibility_reporter"
            )
            collected_errors.append(error_data)
            
    def _test_mps_functionality(self, collected_errors):
        """Test MPS (Apple Silicon) functionality and collect errors"""
        try:
            import torch
            
            # Try to create a tensor on MPS
            try:
                if hasattr(torch.backends, "mps") and torch.backends.mps.is_available():
                    device = torch.device("mps")
                    x = torch.ones(10, 10).to(device)
                    # Try a simple operation
                    y = x + x
                    logger.debug("MPS functionality test passed")
                else:
                    error_data = self.add_error(
                        hardware_type="mps",
                        error_type="not_available",
                        severity="warning",
                        message="MPS reported as available but torch.backends.mps.is_available() returned False",
                        component="hardware_compatibility_reporter"
                    )
                    collected_errors.append(error_data)
            except RuntimeError as e:
                error_data = self.add_error(
                    hardware_type="mps",
                    error_type="runtime_error",
                    severity="error",
                    message=f"MPS functionality test failed: {e}",
                    component="hardware_compatibility_reporter"
                )
                collected_errors.append(error_data)
                
        except ImportError as e:
            error_data = self.add_error(
                hardware_type="mps",
                error_type="import_error",
                severity="warning",
                message=f"Could not import PyTorch for MPS testing: {e}",
                component="hardware_compatibility_reporter"
            )
            collected_errors.append(error_data)
            
    def _test_openvino_functionality(self, collected_errors):
        """Test OpenVINO functionality and collect errors"""
        try:
            # Try to import OpenVINO
            import openvino as ov
            
            # Try to get available devices
            try:
                core = ov.Core()
                devices = core.available_devices
                logger.debug(f"OpenVINO available devices: {devices}")
                
                if not devices:
                    error_data = self.add_error(
                        hardware_type="openvino",
                        error_type="no_devices",
                        severity="warning",
                        message="OpenVINO reported no available devices",
                        component="hardware_compatibility_reporter"
                    )
                    collected_errors.append(error_data)
                    
            except Exception as e:
                error_data = self.add_error(
                    hardware_type="openvino",
                    error_type="initialization_error",
                    severity="error",
                    message=f"OpenVINO initialization failed: {e}",
                    component="hardware_compatibility_reporter"
                )
                collected_errors.append(error_data)
                
        except ImportError as e:
            error_data = self.add_error(
                hardware_type="openvino",
                error_type="import_error",
                severity="warning",
                message=f"Could not import OpenVINO for testing: {e}",
                component="hardware_compatibility_reporter"
            )
            collected_errors.append(error_data)
            
    def _test_webnn_functionality(self, collected_errors):
        """Test WebNN functionality and collect errors"""
        # This is more complex to test in a Python environment
        # In real implementation, this would test the WebNN API
        # For now, just log that it's not fully testable
        error_data = self.add_error(
            hardware_type="webnn",
            error_type="limited_testing",
            severity="info",
            message="WebNN functionality requires browser environment, limited testing available",
            component="hardware_compatibility_reporter"
        )
        collected_errors.append(error_data)
            
    def _test_webgpu_functionality(self, collected_errors):
        """Test WebGPU functionality and collect errors"""
        # This is more complex to test in a Python environment
        # In real implementation, this would test the WebGPU API
        # For now, just log that it's not fully testable
        error_data = self.add_error(
            hardware_type="webgpu",
            error_type="limited_testing",
            severity="info",
            message="WebGPU functionality requires browser environment, limited testing available",
            component="hardware_compatibility_reporter"
        )
        collected_errors.append(error_data)
            
    def add_error(self, hardware_type: str, error_type: str, severity: str, 
                 message: str, component: str, model_name: str = None, 
                 traceback: str = None) -> Dict[str, Any]:
        """
        Add a standardized error to the error registry.
        
        Args:
            hardware_type: Type of hardware (cuda, mps, etc.)
            error_type: Type of error
            severity: Error severity (critical, error, warning, info)
            message: Error message
            component: Component where the error occurred
            model_name: Name of the model (if applicable)
            traceback: Exception traceback (if available)
            
        Returns:
            The error data dictionary
        """
        # Create standardized error data
        error = {
            "hardware_type": hardware_type,
            "error_type": error_type,
            "severity": severity,
            "message": str(message),
            "component": component,
            "timestamp": datetime.now().isoformat(),
            "model_name": model_name,
            "recommendations": self.get_recommendations(hardware_type, error_type)
        }
        
        # Add traceback if available
        if traceback:
            error["traceback"] = traceback
            
        # Add error to main list and registry
        self.errors.append(error)
        
        if hardware_type in self.error_registry:
            self.error_registry[hardware_type].append(error)
        else:
            # For unknown hardware types, default to "all"
            self.error_registry["cpu"].append(error)
            
        # Update error counts
        if severity in self.error_counts:
            self.error_counts[severity] += 1
            
        logger.debug(f"Added {severity} error for {hardware_type}: {message}")
        return error
        
    def get_recommendations(self, hardware_type: str, error_type: str) -> List[str]:
        """
        Get recommendations based on hardware type and error type.
        
        Args:
            hardware_type: Type of hardware
            error_type: Type of error
            
        Returns:
            List of recommendation strings
        """
        # Get templates for this hardware type
        hw_templates = self.recommendation_templates.get(hardware_type, {})
        
        # Get templates for this error type
        error_templates = hw_templates.get(error_type, [])
        
        # If no specific templates for this hardware+error combination,
        # try general templates for the error type
        if not error_templates:
            error_templates = self.recommendation_templates.get("all", {}).get(error_type, [])
            
        # If still no templates, provide a general recommendation
        if not error_templates:
            return ["Check hardware compatibility and system requirements"]
            
        return error_templates
        
    def _get_recommendation_templates(self) -> Dict[str, Dict[str, List[str]]]:
        """
        Get recommendation templates for different hardware and error types.
        
        Returns:
            Nested dictionary of recommendation templates
        """
        return {
            "cuda": {
                "detection_failure": [
                    "Ensure NVIDIA drivers are installed and up to date",
                    "Check that CUDA toolkit is properly installed",
                    "Verify that the GPU is supported by the installed CUDA version"
                ],
                "initialization_failed": [
                    "Restart the system and try again",
                    "Check for conflicting CUDA processes using nvidia-smi",
                    "Verify that the GPU is not in an error state"
                ],
                "memory_pressure": [
                    "Close other applications using GPU memory",
                    "Try using a smaller model or batch size",
                    "Consider using mixed precision (FP16) to reduce memory usage",
                    "Split the model across multiple GPUs if available"
                ],
                "runtime_error": [
                    "Update NVIDIA drivers to the latest version",
                    "Check CUDA and PyTorch compatibility",
                    "Try reducing batch size or model size",
                    "Check for specific CUDA error codes in the message"
                ],
                "compatibility_error": [
                    "Check if the model is compatible with your GPU architecture",
                    "Try using an alternative model or version",
                    "Update to a newer CUDA version if possible"
                ],
                "insufficient_memory": [
                    "Use a smaller model variant if available",
                    "Enable mixed precision training/inference",
                    "Use gradient checkpointing for training",
                    "Try model quantization techniques",
                    "Split the model across multiple GPUs"
                ]
            },
            "mps": {
                "detection_failure": [
                    "Ensure PyTorch is built with MPS support",
                    "Verify macOS version is 12.3 or newer",
                    "Check that you're using PyTorch 1.12 or newer"
                ],
                "not_available": [
                    "Verify macOS version is 12.3 or newer",
                    "Ensure PyTorch is built with MPS support",
                    "Check that MPS is enabled in system settings"
                ],
                "runtime_error": [
                    "Some operations may not be supported by MPS backend",
                    "Try running on CPU instead using device='cpu'",
                    "Update to latest PyTorch version for better MPS support",
                    "Check PyTorch GitHub issues for known MPS limitations"
                ],
                "compatibility_error": [
                    "Some model architectures may not be fully compatible with MPS",
                    "Check for MPS-specific workarounds for this model type",
                    "Consider using CPU backend for this model"
                ]
            },
            "openvino": {
                "import_error": [
                    "Install OpenVINO toolkit using pip install openvino",
                    "Make sure OpenVINO dependencies are installed",
                    "Check OpenVINO documentation for platform-specific setup"
                ],
                "no_devices": [
                    "Check that OpenVINO device drivers are installed",
                    "Verify that hardware acceleration devices are available",
                    "Review OpenVINO device plugin configuration"
                ],
                "initialization_error": [
                    "Reinstall OpenVINO toolkit",
                    "Check system compatibility with OpenVINO",
                    "Verify that required device drivers are installed"
                ]
            },
            "webnn": {
                "limited_testing": [
                    "WebNN requires a browser environment with WebNN API support",
                    "Test in Chrome or Edge browser with WebNN enabled",
                    "Use the web_platform_testing.py script for browser-based testing"
                ],
                "compatibility_error": [
                    "Check that the model architecture is supported by WebNN",
                    "Verify browser support for WebNN API",
                    "Consider using a simpler model for web deployment"
                ]
            },
            "webgpu": {
                "limited_testing": [
                    "WebGPU requires a browser environment with WebGPU API support",
                    "Test in Chrome with WebGPU enabled (chrome://flags)",
                    "Use the web_platform_testing.py script for browser-based testing"
                ],
                "compatibility_error": [
                    "Check that the model architecture is supported by transformers.js",
                    "Verify browser support for WebGPU API",
                    "Consider using a smaller model for web deployment"
                ]
            },
            "all": {
                "import_error": [
                    "Install the required module using pip",
                    "Check for version compatibility issues",
                    "Verify that all dependencies are installed"
                ],
                "missing_component": [
                    "Ensure all required components are installed",
                    "Check file paths for the missing component",
                    "Reinstall the framework if components are missing"
                ],
                "test_error": [
                    "Check logs for detailed error information",
                    "Try testing with a simpler model",
                    "Verify system has sufficient resources for testing"
                ],
                "collection_error": [
                    "Check logs for details on the collection failure",
                    "Verify that required components are available",
                    "Try running with --debug flag for more information"
                ]
            },
            "cpu": {
                "memory_pressure": [
                    "Close unnecessary applications to free memory",
                    "Try using a smaller model or batch size",
                    "Consider adding more RAM to your system",
                    "Enable memory-mapped file loading where applicable"
                ]
            }
        }
        
    def collect_all_errors(self, test_models: List[str] = None) -> int:
        """
        Collect errors from all available components.
        
        Args:
            test_models: List of model names to test for compatibility errors
            
        Returns:
            Total number of errors collected
        """
        # Check component availability
        self.check_components()
        
        # First check hardware detection errors (most basic)
        if self.hardware_detection_available:
            self.collect_hardware_detection_errors()
            
        # Check resource pool errors
        if self.resource_pool_available:
            self.collect_resource_pool_errors()
            
        # Run compatibility tests for models
        if test_models:
            for model in test_models:
                if self.model_integration_available:
                    self.collect_model_integration_errors(model)
        else:
            # Use default model set
            default_models = ["bert-base-uncased", "t5-small", "vit-base-patch16-224", 
                              "gpt2", "facebook/bart-base", "openai/whisper-tiny"]
            
            for model in default_models:
                if self.model_integration_available:
                    self.collect_model_integration_errors(model)
                    
        # Test full hardware stack
        if self.hardware_detection_available:
            self.test_full_hardware_stack()
            
        # Return total error count
        total_errors = sum(self.error_counts.values())
        logger.info(f"Collected a total of {total_errors} errors from all components")
        return total_errors
        
    def generate_report(self, format: str = "markdown") -> str:
        """
        Generate a comprehensive error report.
        
        Args:
            format: Output format ("markdown" or "json")
            
        Returns:
            The report content as a string
        """
        if format == "json":
            return self._generate_json_report()
        else:  # markdown
            return self._generate_markdown_report()
            
    def _generate_json_report(self) -> str:
        """
        Generate a JSON error report.
        
        Returns:
            JSON report as a string
        """
        report_data = {
            "timestamp": datetime.now().isoformat(),
            "error_counts": self.error_counts,
            "errors": self.errors,
            "hardware_errors": self.error_registry,
            "models_tested": list(self.models_tested),
            "components_available": {
                "resource_pool": self.resource_pool_available,
                "hardware_detection": self.hardware_detection_available,
                "model_family_classifier": self.model_classifier_available,
                "hardware_model_integration": self.model_integration_available
            }
        }
        
        # Save to file
        report_path = os.path.join(self.output_dir, f"hardware_compatibility_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        with open(report_path, "w") as f:
            json.dump(report_data, f, indent=2)
            
        logger.info(f"Saved JSON report to {report_path}")
        return json.dumps(report_data, indent=2)
        
    def _generate_markdown_report(self) -> str:
        """
        Generate a Markdown error report.
        
        Returns:
            Markdown report as a string
        """
        components_checked = []
        if self.resource_pool_available:
            components_checked.append("ResourcePool")
        if self.hardware_detection_available:
            components_checked.append("HardwareDetection")
        if self.model_classifier_available:
            components_checked.append("ModelFamilyClassifier")
        if self.model_integration_available:
            components_checked.append("HardwareModelIntegration")
            
        # Create report header
        lines = [
            "# Hardware Compatibility Report",
            f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "## Summary",
            "",
            f"- Critical Errors: {self.error_counts['critical']}",
            f"- Errors: {self.error_counts['error']}",
            f"- Warnings: {self.error_counts['warning']}",
            f"- Informational: {self.error_counts['info']}",
            "",
            "## Components Checked",
            ""
        ]
        
        # Add component availability
        for component in components_checked:
            lines.append(f"- ✅ {component}")
            
        if not components_checked:
            lines.append("- ❌ No components available")
            
        # Add models tested
        lines.append("")
        lines.append("## Models Tested")
        lines.append("")
        
        if self.models_tested:
            for model in sorted(self.models_tested):
                lines.append(f"- {model}")
        else:
            lines.append("- No models tested")
            
        # Add hardware compatibility matrix
        lines.append("")
        lines.append("## Hardware Compatibility Matrix")
        lines.append("")
        lines.append(self._generate_compatibility_matrix_markdown())
        
        # Add errors by severity
        for severity in ["critical", "error", "warning", "info"]:
            count = self.error_counts[severity]
            if count > 0:
                severity_title = severity.capitalize()
                lines.append("")
                lines.append(f"## {severity_title} Issues ({count})")
                lines.append("")
                
                # Filter errors by severity
                severity_errors = [e for e in self.errors if e["severity"] == severity]
                
                for error in severity_errors:
                    hw_type = error["hardware_type"]
                    error_type = error["error_type"]
                    message = error["message"]
                    component = error["component"]
                    model = error.get("model_name", "N/A")
                    
                    lines.append(f"### {hw_type.upper()}: {error_type}")
                    lines.append("")
                    lines.append(f"- **Component**: {component}")
                    lines.append(f"- **Model**: {model}")
                    lines.append(f"- **Message**: {message}")
                    lines.append("")
                    
                    # Add recommendations
                    recommendations = error.get("recommendations", [])
                    if recommendations:
                        lines.append("**Recommendations**:")
                        lines.append("")
                        for rec in recommendations:
                            lines.append(f"- {rec}")
                        lines.append("")
                        
                    # Add traceback if available and severity is error or critical
                    if severity in ["critical", "error"] and "traceback" in error:
                        lines.append("<details>")
                        lines.append("<summary>Error Details</summary>")
                        lines.append("")
                        lines.append("```")
                        lines.append(error["traceback"])
                        lines.append("```")
                        lines.append("</details>")
                        lines.append("")
                        
        # Save to file
        report_content = "\n".join(lines)
        report_path = os.path.join(self.output_dir, f"hardware_compatibility_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md")
        with open(report_path, "w") as f:
            f.write(report_content)
            
        logger.info(f"Saved Markdown report to {report_path}")
        return report_content
        
    def generate_compatibility_matrix(self, format: str = "markdown") -> str:
        """
        Generate a hardware compatibility matrix based on errors.
        
        Args:
            format: Output format ("markdown" or "json")
            
        Returns:
            The compatibility matrix as a string
        """
        if format == "json":
            return self._generate_compatibility_matrix_json()
        else:  # markdown
            return self._generate_compatibility_matrix_markdown()
            
    def _generate_compatibility_matrix_json(self) -> str:
        """
        Generate a JSON hardware compatibility matrix.
        
        Returns:
            JSON compatibility matrix as a string
        """
        # Define hardware types and model families
        hardware_types = ["cuda", "rocm", "mps", "openvino", "webnn", "webgpu", "cpu"]
        model_families = ["embedding", "text_generation", "vision", "audio", "multimodal"]
        
        # Create matrix structure
        matrix = {
            "timestamp": datetime.now().isoformat(),
            "hardware_types": hardware_types,
            "model_families": model_families,
            "compatibility": {}
        }
        
        # Fill in compatibility data based on errors
        for family in model_families:
            matrix["compatibility"][family] = {}
            for hw_type in hardware_types:
                # Get errors for this hardware type and model family
                hw_errors = self.error_registry.get(hw_type, [])
                family_errors = [e for e in hw_errors if e.get("model_name") and 
                                self._get_model_family(e.get("model_name")) == family]
                
                # Calculate compatibility score (0-3)
                # 0 = Not compatible (critical errors)
                # 1 = Low compatibility (errors)
                # 2 = Medium compatibility (warnings)
                # 3 = High compatibility (no issues)
                score = 3  # Start with high compatibility
                
                for e in family_errors:
                    if e["severity"] == "critical":
                        score = 0
                        break
                    elif e["severity"] == "error" and score > 1:
                        score = 1
                    elif e["severity"] == "warning" and score > 2:
                        score = 2
                        
                # Map score to compatibility level
                compatibility = {
                    0: "incompatible",
                    1: "low",
                    2: "medium",
                    3: "high"
                }[score]
                
                # Add to matrix
                matrix["compatibility"][family][hw_type] = {
                    "level": compatibility,
                    "score": score,
                    "error_count": len(family_errors)
                }
                
        # Save to file
        matrix_path = os.path.join(self.output_dir, f"hardware_compatibility_matrix_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        with open(matrix_path, "w") as f:
            json.dump(matrix, f, indent=2)
            
        logger.info(f"Saved JSON compatibility matrix to {matrix_path}")
        return json.dumps(matrix, indent=2)
        
    def _generate_compatibility_matrix_markdown(self) -> str:
        """
        Generate a Markdown hardware compatibility matrix.
        
        Returns:
            Markdown compatibility matrix as a string
        """
        # Define hardware types and model families
        hardware_types = ["cuda", "rocm", "mps", "openvino", "webnn", "webgpu", "cpu"]
        model_families = ["embedding", "text_generation", "vision", "audio", "multimodal"]
        
        # Create matrix header
        lines = [
            "| Model Family | " + " | ".join(hw.upper() for hw in hardware_types) + " |",
            "|--------------|" + "|".join("-" * (len(hw) + 2) for hw in hardware_types) + "|"
        ]
        
        # Fill in matrix data
        for family in model_families:
            cells = [family.replace("_", " ").title()]
            
            for hw_type in hardware_types:
                # Get errors for this hardware type and model family
                hw_errors = self.error_registry.get(hw_type, [])
                family_errors = [e for e in hw_errors if e.get("model_name") and 
                                self._get_model_family(e.get("model_name")) == family]
                
                # Calculate compatibility level based on severity of errors
                has_critical = any(e["severity"] == "critical" for e in family_errors)
                has_error = any(e["severity"] == "error" for e in family_errors)
                has_warning = any(e["severity"] == "warning" for e in family_errors)
                
                if has_critical:
                    cells.append("❌")  # Incompatible
                elif has_error:
                    cells.append("⚠️")  # Low compatibility
                elif has_warning:
                    cells.append("⚠️")  # Medium compatibility
                else:
                    cells.append("✅")  # High compatibility
                    
            # Add row to matrix
            lines.append("| " + " | ".join(cells) + " |")
            
        # Add legend
        lines.extend([
            "",
            "Legend:",
            "- ✅ Compatible - No issues detected",
            "- ⚠️ Partially Compatible - Some issues may occur",
            "- ❌ Incompatible - Critical issues prevent operation"
        ])
        
        return "\n".join(lines)
        
    def _get_model_family(self, model_name: str) -> str:
        """
        Get the model family for a model name using heuristics.
        
        Args:
            model_name: Name of the model
            
        Returns:
            Model family string
        """
        model_name = model_name.lower()
        
        if "bert" in model_name or "roberta" in model_name or "distil" in model_name:
            return "embedding"
        elif "gpt" in model_name or "t5" in model_name or "llama" in model_name or "bart" in model_name:
            return "text_generation"
        elif "vit" in model_name or "resnet" in model_name or "clip" in model_name:
            return "vision"
        elif "whisper" in model_name or "wav2vec" in model_name or "hubert" in model_name:
            return "audio"
        elif "llava" in model_name or "blip" in model_name:
            return "multimodal"
        else:
            return "unknown"
            
    def save_to_file(self, content: str, filename: str) -> str:
        """
        Save content to a file in the output directory.
        
        Args:
            content: The content to save
            filename: The filename (without directory path)
            
        Returns:
            The full path to the saved file
        """
        full_path = os.path.join(self.output_dir, filename)
        with open(full_path, "w") as f:
            f.write(content)
        logger.info(f"Saved to {full_path}")
        return full_path

def main():
    """Command-line interface for the hardware compatibility reporter."""
    parser = argparse.ArgumentParser(description="Hardware Compatibility Error Reporting System")
    parser.add_argument("--output-dir", default=DEFAULT_OUTPUT_DIR,
                     help="Directory to save reports")
    parser.add_argument("--collect-all", action="store_true",
                     help="Collect errors from all available components")
    parser.add_argument("--test-hardware", action="store_true",
                     help="Test the full hardware stack")
    parser.add_argument("--check-model", type=str,
                     help="Check compatibility for a specific model")
    parser.add_argument("--matrix", action="store_true",
                     help="Generate and display hardware compatibility matrix")
    parser.add_argument("--format", choices=["markdown", "json"], default="markdown",
                     help="Output format for reports")
    parser.add_argument("--debug", action="store_true",
                     help="Enable debug logging")
    args = parser.parse_args()
    
    # Create reporter
    reporter = HardwareCompatibilityReporter(output_dir=args.output_dir, debug=args.debug)
    
    # Check component availability
    reporter.check_components()
    
    # Perform requested actions
    if args.collect_all:
        reporter.collect_all_errors()
        report_content = reporter.generate_report(format=args.format)
        print(f"Generated report with {sum(reporter.error_counts.values())} issues detected")
        
    elif args.test_hardware:
        reporter.test_full_hardware_stack()
        report_content = reporter.generate_report(format=args.format)
        print(f"Hardware test completed, {sum(reporter.error_counts.values())} issues detected")
        
    elif args.check_model:
        if reporter.model_integration_available:
            reporter.collect_model_integration_errors(args.check_model)
            report_content = reporter.generate_report(format=args.format)
            print(f"Model compatibility check completed for {args.check_model}")
        else:
            print("Model integration component not available, cannot check model compatibility")
            
    elif args.matrix:
        # Collect some errors to generate matrix
        reporter.collect_all_errors()
        matrix_content = reporter.generate_compatibility_matrix(format=args.format)
        print(matrix_content)
        
    else:
        # No specific action requested, print help
        parser.print_help()
        
if __name__ == "__main__":
    main()