#!/usr/bin/env python3
"""
Claude Output Sanity Check Script

This script automatically fixes common issues in code generated by Claude:
- Incorrect boolean values (false/true → False/True)
- Incorrect quotation mark types (curly quotes → straight quotes)
- Indentation problems
- Missing colons in Python control structures
- Common typos and syntax errors
- Incorrect brackets and parentheses
- Import statement errors

Usage:
    ./claude_sanity_check.py <file_or_directory> [options]

This helps reduce token count in conversations by automatically fixing
common issues before executing Claude-generated code.

NOTE: This script incorporates functionality from fix_indentation.py.
"""

import os
import sys
import re
import argparse
from pathlib import Path
import tokenize
import io

# ------------------------------------------------------------------------------
# Indentation fixing code (from fix_indentation.py)
# ------------------------------------------------------------------------------

def analyze_indentation(content):
    """
    Analyze the indentation style in a file.
    Returns:
        tuple: (use_tabs, indent_size, inconsistent_lines)
            - use_tabs: True if tabs are used, False if spaces
            - indent_size: Detected indent size (usually 2, 4, or 8 spaces)
            - inconsistent_lines: List of line numbers with inconsistent indentation
    """
    lines = content.splitlines()
    
    # Count occurrences of tabs and spaces at line beginnings
    tab_count = 0
    space_count = 0
    space_indent_sizes = {}
    inconsistent_lines = []
    
    for i, line in enumerate(lines, 1):
        # Skip empty lines and comment-only lines
        if not line.strip() or line.strip().startswith('#'):
            continue
            
        # Calculate leading whitespace
        leading_whitespace = len(line) - len(line.lstrip())
        if leading_whitespace == 0:
            continue
            
        if line[0] == '\t':
            tab_count += 1
        elif line[0] == ' ':
            space_count += 1
            
            # Try to determine space indent size
            space_indent = len(line) - len(line.lstrip(' '))
            for size in [2, 4, 8]:
                if space_indent % size == 0:
                    space_indent_sizes[size] = space_indent_sizes.get(size, 0) + 1
        
        # Check for mixed indentation in the same line
        if '\t' in line[:leading_whitespace] and ' ' in line[:leading_whitespace]:
            inconsistent_lines.append(i)
    
    # Determine the dominant indentation style
    use_tabs = tab_count > space_count
    
    # Determine the most common indent size for spaces
    indent_size = 4  # default
    if space_indent_sizes:
        indent_size = max(space_indent_sizes.items(), key=lambda x: x[1])[0]
    
    return use_tabs, indent_size, inconsistent_lines

def fix_indentation(content, use_tabs, indent_size):
    """
    Fix indentation issues in the content based on the determined style.
    """
    lines = content.splitlines()
    fixed_lines = []
    
    for line in lines:
        if not line.strip():
            # Keep empty lines as they are
            fixed_lines.append(line)
            continue
            
        # Determine leading whitespace
        leading_whitespace = len(line) - len(line.lstrip())
        if leading_whitespace == 0:
            # No indentation needed
            fixed_lines.append(line)
            continue
        
        # Calculate indentation depth
        if use_tabs:
            # Convert spaces to tabs
            stripped = line.lstrip()
            indent_depth = leading_whitespace // indent_size if not use_tabs else leading_whitespace
            fixed_line = '\t' * indent_depth + stripped
        else:
            # Convert tabs to spaces
            stripped = line.lstrip()
            # Estimate tab depth by counting tabs and spaces
            tab_count = line[:leading_whitespace].count('\t')
            space_count = line[:leading_whitespace].count(' ')
            indent_depth = tab_count + (space_count // indent_size)
            fixed_line = ' ' * (indent_size * indent_depth) + stripped
        
        fixed_lines.append(fixed_line)
    
    return '\n'.join(fixed_lines)

# ------------------------------------------------------------------------------
# Additional Claude-specific fixes
# ------------------------------------------------------------------------------

def fix_boolean_values(content):
    """
    Fix lowercase boolean values (true/false → True/False)
    but only when they're actually boolean values, not variable names or strings.
    """
    # First pass: build a list of lines to check
    lines = content.splitlines()
    fixed_lines = []
    
    # Regular expressions for whole-word matches
    true_pattern = r'(?<!\w)true(?!\w)'
    false_pattern = r'(?<!\w)false(?!\w)'
    
    for line in lines:
        # Skip comments and strings for this basic check
        if line.strip().startswith('#'):
            fixed_lines.append(line)
            continue
            
        # Replace boolean values
        line = re.sub(true_pattern, 'True', line)
        line = re.sub(false_pattern, 'False', line)
        
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def fix_quotation_marks(content):
    """
    Fix curly quotes and other incorrect quotation marks in Python code.
    """
    # Map of incorrect quotes to correct ones
    quote_map = {
        '"': '"',  # Curly left double quote
        '"': '"',  # Curly right double quote
        ''': "'",  # Curly left single quote
        ''': "'",  # Curly right single quote
        '′': "'",  # Prime symbol
        '″': '"',  # Double prime symbol
        '`': "'",  # Backtick
        '´': "'",  # Acute accent
    }
    
    # Process the content
    lines = content.splitlines()
    fixed_lines = []
    
    for line in lines:
        for wrong, right in quote_map.items():
            line = line.replace(wrong, right)
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def fix_none_case(content):
    """Fix lowercase 'none' to 'None'"""
    # First pass: build a list of lines to check
    lines = content.splitlines()
    fixed_lines = []
    
    # Regular expression for whole-word match
    none_pattern = r'(?<!\w)none(?!\w)'
    
    for line in lines:
        # Skip comments and strings for this basic check
        if line.strip().startswith('#'):
            fixed_lines.append(line)
            continue
            
        # Replace None value
        line = re.sub(none_pattern, 'None', line)
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def fix_common_typos(content):
    """Fix common code typos Claude might make"""
    # Common typos and their fixes
    replacements = [
        (r'printt\(', 'print('),
        (r'impotr\s+', 'import '),
        (r'retrun\s+', 'return '),
        (r'defien\s+', 'define '),
        (r'functoin', 'function'),
        (r'(?<!\w)flase(?!\w)', 'False'),
        (r'(?<!\w)ture(?!\w)', 'True'),
        (r'(?<!\w)slef(?!\w)', 'self'),
        (r'(?<!\w)lenght(?!\w)', 'length'),
        (r'(?<!\w)lenght\(', 'len('),
        (r'(?<!\w)funciton(?!\w)', 'function'),
        (r'(?<!\w)fucntion(?!\w)', 'function'),
        (r'(?<!\w)dictonary(?!\w)', 'dictionary'),
    ]
    
    lines = content.splitlines()
    fixed_lines = []
    
    for line in lines:
        for pattern, replacement in replacements:
            line = re.sub(pattern, replacement, line)
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def fix_missing_colons(content):
    """
    Fix missing colons in function/class definitions and if/for/while statements.
    This is a common issue with Claude output.
    """
    # Pattern to find lines that should end with a colon but don't
    patterns = [
        # Function definition: def func(...) with no colon
        (r'^(\s*def\s+\w+\s*\([^)]*\))(\s*)$', r'\1:\2'),
        # Class definition: class Name(...) with no colon
        (r'^(\s*class\s+\w+(?:\s*\([^)]*\))?)(\s*)$', r'\1:\2'),
        # if statements: if condition with no colon
        (r'^(\s*if\s+[^:]+)(\s*)$', r'\1:\2'),
        # else statements with no colon
        (r'^(\s*else)(\s*)$', r'\1:\2'),
        # elif statements with no colon
        (r'^(\s*elif\s+[^:]+)(\s*)$', r'\1:\2'),
        # for loops with no colon
        (r'^(\s*for\s+[^:]+)(\s*)$', r'\1:\2'),
        # while loops with no colon
        (r'^(\s*while\s+[^:]+)(\s*)$', r'\1:\2'),
        # except blocks with no colon
        (r'^(\s*except(?:\s+[^:]+)?)(\s*)$', r'\1:\2'),
        # finally blocks with no colon
        (r'^(\s*finally)(\s*)$', r'\1:\2'),
        # with statements with no colon
        (r'^(\s*with\s+[^:]+)(\s*)$', r'\1:\2'),
    ]
    
    lines = content.splitlines()
    fixed_lines = []
    
    # Track if we're in a multiline string
    in_multiline_string = False
    string_delimiter = None
    
    for line in lines:
        if not in_multiline_string:
            # Skip comments
            if line.strip().startswith('#'):
                fixed_lines.append(line)
                continue
                
            # Check for start of multiline string
            triple_single = line.count("'''") % 2 == 1
            triple_double = line.count('"""') % 2 == 1
            
            if triple_single:
                in_multiline_string = True
                string_delimiter = "'''"
            elif triple_double:
                in_multiline_string = True
                string_delimiter = '"""'
            
            # Outside of strings, apply fixes
            if not in_multiline_string:
                for pattern, replacement in patterns:
                    # Only fix if it looks like a code construct, not a comment or string
                    if re.match(pattern, line) and ':' not in line and '#' not in line:
                        line = re.sub(pattern, replacement, line)
                        break
        else:
            # Check for end of multiline string
            if string_delimiter in line:
                in_multiline_string = False
                string_delimiter = None
        
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def fix_wrong_brackets(content):
    """Fix incorrect bracket pairs in content."""
    lines = content.splitlines()
    fixed_lines = []
    
    # Track if we're in a multiline string
    in_multiline_string = False
    string_delimiter = None
    
    for line in lines:
        if not in_multiline_string:
            # Skip comments
            if line.strip().startswith('#'):
                fixed_lines.append(line)
                continue
                
            # Check for start of multiline string
            triple_single = line.count("'''") % 2 == 1
            triple_double = line.count('"""') % 2 == 1
            
            if triple_single:
                in_multiline_string = True
                string_delimiter = "'''"
            elif triple_double:
                in_multiline_string = True
                string_delimiter = '"""'
            
            # Outside of strings, apply fixes
            if not in_multiline_string:
                # Fix bracket pairs
                if '[' not in line and ']' in line:
                    line = line.replace(']', ')')
                if ']' not in line and '[' in line and ')' in line:
                    line = line.replace('[', '(')
                if '(' not in line and ')' in line:
                    line = line.replace(')', ']')
                if ')' not in line and '(' in line and ']' in line:
                    line = line.replace('(', '[')
        else:
            # Check for end of multiline string
            if string_delimiter in line:
                in_multiline_string = False
                string_delimiter = None
        
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def fix_import_statements(content):
    """
    Fix common import statement errors:
    - Missing 'as' keyword
    - Trailing commas in from ... import
    """
    lines = content.splitlines()
    fixed_lines = []
    
    import_patterns = [
        # Fix "import X Y" to "import X as Y"
        (r'^(\s*import\s+\w+)\s+(\w+)$', r'\1 as \2'),
        # Fix trailing comma in import statements
        (r'^(\s*from\s+[\w.]+\s+import\s+[^,]+),\s*$', r'\1'),
        # Fix "from X imports Y" to "from X import Y"
        (r'^(\s*from\s+[\w.]+)\s+imports\s+', r'\1 import '),
    ]
    
    for line in lines:
        # Skip comments
        if line.strip().startswith('#'):
            fixed_lines.append(line)
            continue
            
        for pattern, replacement in import_patterns:
            if re.match(pattern, line):
                line = re.sub(pattern, replacement, line)
        
        fixed_lines.append(line)
    
    return '\n'.join(fixed_lines)

def process_file(file_path, dry_run=False, verbose=False):
    """
    Process a single Python file to fix Claude output issues.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Skip empty files
        if not content.strip():
            if verbose:
                print(f"Skipping empty file: {file_path}")
            return False
        
        # Apply all fixes
        fixed_content = content
        
        # First fix all Claude-specific issues
        fixed_content = fix_boolean_values(fixed_content)
        fixed_content = fix_none_case(fixed_content)
        fixed_content = fix_quotation_marks(fixed_content)
        fixed_content = fix_common_typos(fixed_content)
        fixed_content = fix_missing_colons(fixed_content)
        fixed_content = fix_wrong_brackets(fixed_content)
        fixed_content = fix_import_statements(fixed_content)
        
        # Then fix indentation
        use_tabs, indent_size, inconsistent_lines = analyze_indentation(fixed_content)
        if inconsistent_lines:
            fixed_content = fix_indentation(fixed_content, use_tabs, indent_size)
        
        # Check if changes were made
        if content != fixed_content:
            if verbose:
                print(f"Processing {file_path} - Found issues to fix")
            
            if dry_run:
                if verbose:
                    print(f"  Would fix issues in {file_path} (dry run)")
                return True
            else:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(fixed_content)
                if verbose:
                    print(f"  Fixed issues in {file_path}")
                return True
        else:
            if verbose:
                print(f"No issues found in {file_path}")
            return False
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return False

def is_python_file(file_path):
    """Check if a file is a Python file."""
    return file_path.suffix == '.py'

def process_directory(directory, recursive=True, dry_run=False, verbose=False):
    """
    Process Python files in a directory to fix Claude output issues.
    """
    directory = Path(directory)
    fixed_count = 0
    total_count = 0
    
    if recursive:
        python_files = list(directory.glob('**/*.py'))
    else:
        python_files = list(directory.glob('*.py'))
    
    for file_path in python_files:
        total_count += 1
        if process_file(file_path, dry_run, verbose):
            fixed_count += 1
    
    return fixed_count, total_count

def main():
    parser = argparse.ArgumentParser(
        description='Fix common issues in Python code generated by Claude.',
        epilog="""
        This tool automatically fixes common issues in code generated by Claude,
        including incorrect boolean values, quotation marks, indentation, and more.
        It should be run on Claude-generated code before attempting to execute it.
        """
    )
    
    parser.add_argument('path', type=str, help='File or directory to process')
    parser.add_argument('--recursive', '-r', action='store_true', help='Recursively process directories')
    parser.add_argument('--dry-run', '-d', action='store_true', help='Show what would be done without making changes')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    path = Path(args.path)
    
    if not path.exists():
        print(f"Error: Path {path} does not exist")
        return 1
    
    print(f"{'Scanning' if args.dry_run else 'Fixing'} Claude-generated Python files...")
    
    if path.is_file():
        if is_python_file(path):
            result = process_file(path, args.dry_run, args.verbose)
            fixed_count = 1 if result else 0
            print(f"Results: {fixed_count} file would be fixed" if args.dry_run else f"Results: {fixed_count} file fixed")
        else:
            print(f"Error: {path} is not a Python file")
            return 1
    elif path.is_dir():
        fixed_count, total_count = process_directory(path, args.recursive, args.dry_run, args.verbose)
        action = "would be fixed" if args.dry_run else "fixed"
        print(f"Results: {fixed_count}/{total_count} files {action}")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())