<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Datacenter Network Acceleration Simulation</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    h1, h2 {
      color: #1a365d;
      text-align: center;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .game-board {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 15px;
      margin-bottom: 20px;
    }
    canvas {
      border: 1px solid #ddd;
      display: block;
      margin: 0 auto;
      width: 700px;
      height: 500px; /* Increased height from 400px */
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    button {
      background-color: #4338ca;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #3730a3;
    }
    .toggle-container {
      display: flex;
      align-items: center;
      background-color: #f0f4f8;
      padding: 5px 15px;
      border-radius: 30px;
      margin: 0 10px;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
      margin: 0 10px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 30px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #10b981;
    }
    input:checked + .slider:before {
      transform: translateX(30px);
    }
    .stats {
      margin-top: 10px;
      font-size: 14px;
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
    }
    .stat-box {
      background-color: #f0f9ff;
      padding: 8px 15px;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin: 5px;
      min-width: 150px;
    }
    .legend {
      margin-top: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
    }
    .legend-color {
      width: 15px;
      height: 15px;
      border-radius: 3px;
    }
    .explanation {
      margin-top: 30px;
      padding: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .queue-panel {
      background-color: #f8fafc;
      border-radius: 8px;
      padding: 10px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .queue-title {
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .queue-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 10px;
      max-width: 700px;
      margin: 0 auto;
    }
    
    .node-queue {
      background-color: white;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 8px;
      min-height: 100px;
    }
    
    .queue-header {
      background-color: #3b82f6;
      color: white;
      padding: 3px 6px;
      border-radius: 3px;
      font-size: 12px;
      margin-bottom: 5px;
      text-align: center;
    }
    
    .queue-item {
      margin: 3px 0;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 10px;
      display: flex;
      justify-content: space-between;
    }
    
    .queue-item.https {
      background-color: #f59e0b; /* HuggingFace Hub color */
      color: white;
    }
    
    .queue-item.p2p {
      background-color: #10b981; /* P2P color */
      color: white;
    }
    
    .queue-item.in-progress {
      border: 2px solid #4338ca;
    }
    
    .source-label {
      display: inline-block;
      padding: 1px 3px;
      border-radius: 2px;
      font-size: 8px;
      margin-left: 2px;
      background-color: #1e3a8a;
    }
    
    .queue-status {
      font-size: 11px;
      text-align: center;
      margin-top: 5px;
      color: #6b7280;
    }

    .network-stats {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      padding: 5px;
      border-radius: 4px;
      font-size: 10px;
      pointer-events: none;
    }
    
    .connection-label {
      position: absolute;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 2px 4px;
      border-radius: 2px;
      font-size: 10px;
      pointer-events: none;
    }

    .network-traffic {
      position: absolute;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 10px;
      pointer-events: none;
    }

    .node-status {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #e2e8f0;
      padding: 4px;
      border-radius: 4px;
      font-size: 10px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Datacenter Network Acceleration Simulation</h1>
    <h2>Hub-and-Spoke vs Peer-to-Peer Distribution</h2>
    
    <div class="controls">
      <button id="startButton">Start Simulation</button>
      <button id="pauseButton">Pause</button>
      <button id="resetButton">Reset</button>
      
      <div class="toggle-container">
        <span>P2P Mode:</span>
        <label class="toggle-switch">
          <input type="checkbox" id="p2pToggle">
          <span class="slider"></span>
        </label>
        <span id="modeLabel">Off</span>
      </div>
      
      <div id="timer" style="margin-left: 10px; line-height: 40px;">Time: 0s</div>
    </div>
    
    <div class="game-board">
      <canvas id="networkCanvas" width="700" height="500"></canvas>
      
      <div class="stats">
        <div class="stat-box">
          <strong>Progress:</strong>
          <div id="progress">0% Complete</div>
        </div>
        <div class="stat-box">
          <strong>Speed:</strong>
          <div id="speed">0 MB/s</div>
        </div>
        <div class="stat-box">
          <strong>Est. Completion:</strong>
          <div id="timeEstimate">N/A</div>
        </div>
        <div class="stat-box">
          <strong>Mode:</strong>
          <div id="networkMode">Hub-and-Spoke</div>
        </div>
      </div>
      
      <div class="queue-panel">
        <div class="queue-title">Download Queues</div>
        <div class="queue-container" id="queueContainer">
          <!-- Queue items will be dynamically inserted here -->
        </div>
      </div>
    </div>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background-color: #3b82f6;"></div>
        <span>Data Center</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #f59e0b;"></div>
        <span>HuggingFace Hub</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ef4444;"></div>
        <span>Network Congestion</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #8b5cf6;"></div>
        <span>Data Block (100MB)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #10b981;"></div>
        <span>P2P Connection</span>
      </div>
    </div>
    
    <div class="explanation">
      <h3>Datacenter Network Speed Acceleration Simulation</h3>
      <p>This simulation demonstrates how peer-to-peer networking can dramatically accelerate downloading a large 1TB dataset (10,000 blocks of 100MB each) across multiple datacenters. It compares two different network strategies:</p>
      
      <p><strong>Hub-and-Spoke Mode (P2P Off):</strong> All nine machines across three datacenters download from a central HuggingFace Hub. Each connection to the hub is limited to 1 Gbps (125 MB/s). When multiple connections try to download simultaneously, congestion occurs and slows everyone down - a common bottleneck in traditional datacenter architectures.</p>
      
      <p><strong>Peer-to-Peer Mode (P2P On):</strong> Machines initially download some blocks from a central source at 1 Gbps, but then share these blocks with each other at datacenter interconnect speeds of 100 Gbps (12,500 MB/s). The P2P architecture creates a resilient network where downloading gets exponentially faster as more nodes join and share data, maximizing the high-speed internal datacenter network infrastructure.</p>
      
      <p>Toggle the P2P switch to see how modern datacenter networks can be accelerated by adding peer-to-peer distribution. Notice how in P2P mode, the network bandwidth utilization increases dramatically as nodes share data directly with each other instead of repeatedly downloading the same blocks from a central source.</p>
    </div>
  </div>
  
  <script>
    // Add block hash generation at the start of the script
    // Configuration
    const TOTAL_BLOCKS = 10000; // 1TB = 10,000 blocks of 100MB
    const HUB_DOWNLOAD_SPEED = 125; // 1 Gbps = 125 MB/s
    const P2P_LINK_SPEED = 12500; // 100 Gbps = 12,500 MB/s
    const BLOCK_SIZE = 100; // 100MB
    const SPEED_ROLLING_WINDOW = 3; // 3 second rolling average for speed

    // Network configuration
    const GBIT_SPEED = 125; // 1 Gbit = 125 MB/s
    const HUNDRED_GBIT_SPEED = 12500; // 100 Gbit = 12,500 MB/s
    const ROLLING_WINDOW = 5; // 5 second rolling average for traffic
    const PACKET_SIZE = 100; // 100MB packets

    // Generate unique 8-digit block hashes for all blocks in the dataset
    const blockHashes = [];
    function generateBlockHashes() {
      const chars = '0123456789abcdef';
      for (let i = 0; i < TOTAL_BLOCKS; i++) {
        let hash = '';
        for (let j = 0; j < 8; j++) {
          hash += chars[Math.floor(Math.random() * chars.length)];
        }
        blockHashes.push(hash);
      }
    }
    // Generate the block hashes immediately
    generateBlockHashes();

    // Canvas setup
    const canvas = document.getElementById('networkCanvas');
    const ctx = canvas.getContext('2d');

    // UI elements
    const startButton = document.getElementById('startButton');
    const pauseButton = document.getElementById('pauseButton');
    const resetButton = document.getElementById('resetButton');
    const p2pToggle = document.getElementById('p2pToggle');
    const modeLabel = document.getElementById('modeLabel');
    const timerElement = document.getElementById('timer');
    const networkMode = document.getElementById('networkMode');

    // Stats elements
    const progress = document.getElementById('progress');
    const speed = document.getElementById('speed');
    const timeEstimate = document.getElementById('timeEstimate');

    // Game state
    let isRunning = false;
    let isPeerToPeer = false;
    let gameTime = 0;
    let animationFrameId;
    let lastTimestamp = 0;

    // Define data centers - 3x3 grid layout with adjusted vertical positions
    const dataCenters = [
      // Row 1
      { id: 'DC1-1', x: 175, y: 150, color: '#3b82f6' },  // Shifted down from 100
      { id: 'DC1-2', x: 350, y: 150, color: '#3b82f6' },  // Shifted down from 100
      { id: 'DC1-3', x: 525, y: 150, color: '#3b82f6' },  // Shifted down from 100
      
      // Row 2
      { id: 'DC2-1', x: 175, y: 250, color: '#3b82f6' },  // Shifted down from 200
      { id: 'DC2-2', x: 350, y: 250, color: '#3b82f6' },  // Shifted down from 200
      { id: 'DC2-3', x: 525, y: 250, color: '#3b82f6' },  // Shifted down from 200
      
      // Row 3
      { id: 'DC3-1', x: 175, y: 350, color: '#3b82f6' },  // Shifted down from 300
      { id: 'DC3-2', x: 350, y: 350, color: '#3b82f6' },  // Shifted down from 300
      { id: 'DC3-3', x: 525, y: 350, color: '#3b82f6' },  // Shifted down from 300
    ];

    // Hub - centered above the grid
    const huggingFaceHub = { id: 'Hub', x: 350, y: 80, color: '#f59e0b' };

    // Create p2p connections - fully connected mesh within grid
    const p2pConnections = [];
    for (let i = 0; i < dataCenters.length; i++) {
      for (let j = i + 1; j < dataCenters.length; j++) {
        p2pConnections.push({
          from: i,
          to: j,
          active: false
        });
      }
    }

    // Download state
    const downloadState = {
      blocksDownloaded: 0,
      totalUniqueBlocks: 0,
      nodesState: dataCenters.map(() => ({
        blocksDownloaded: 0,
        blockIds: new Set(),
        pendingTransfers: [],
        downloadingBlock: false,
        blockProgress: 0,
        blockStartTime: 0,
        queue: [],  // Queue of blocks to download
        queueCapacity: 5,  // Maximum queue size
        speedHistory: [],  // Speed history for rolling average
        currentSpeed: 0    // Current speed in MB/s
      })),
      totalBlocks: TOTAL_BLOCKS,
      currentSpeed: 0,
      speedHistory: [],  // Speed history for rolling average
      activeDownloads: 0,
      blockAvailability: new Array(TOTAL_BLOCKS).fill(false)
    };

    // Add network monitoring state
    const networkState = {
      hub: {
        trafficHistory: [],
        currentSpeed: 0,
        lastUpdate: 0,
        activeConnections: 0,
        maxSpeed: GBIT_SPEED
      },
      nodes: dataCenters.map(() => ({
        trafficHistory: [],
        currentSpeed: 0,
        lastUpdate: 0,
        activeConnections: 0,
        maxSpeed: HUNDRED_GBIT_SPEED
      }))
    };

    // Reset simulation
    function resetSimulation() {
      gameTime = 0;
      lastTimestamp = 0;
      timerElement.textContent = 'Time: 0s';

      // Reset state
      downloadState.blocksDownloaded = 0;
      downloadState.totalUniqueBlocks = 0;
      downloadState.activeDownloads = 0;
      downloadState.currentSpeed = 0;
      downloadState.speedHistory = [];
      downloadState.blockAvailability = new Array(TOTAL_BLOCKS).fill(false);
      
      downloadState.nodesState = dataCenters.map(() => ({
        blocksDownloaded: 0,
        blockIds: new Set(),
        pendingTransfers: [],
        downloadingBlock: false,
        blockProgress: 0,
        blockStartTime: 0,
        queue: [],
        queueCapacity: 5,
        speedHistory: [],
        currentSpeed: 0
      }));

      // Reset P2P connections
      p2pConnections.forEach(conn => {
        conn.active = false;
      });

      // Update stats
      updateStatistics();
      
      // Create queue HTML
      renderQueues();

      // Draw initial state
      drawNetwork();
      initializePeerConnections();
    }
    
    // Render queue display
    function renderQueues() {
      const queueContainer = document.getElementById('queueContainer');
      queueContainer.innerHTML = '';
      
      // Ensure we have a grid layout that matches our 3x3 data center structure
      downloadState.nodesState.forEach((nodeState, index) => {
        const nodeQueue = document.createElement('div');
        nodeQueue.className = 'node-queue';
        nodeQueue.id = `queue-${index}`;
        
        // Get the corresponding data center for positioning reference
        const dataCenter = dataCenters[index];
        
        const nodeHeader = document.createElement('div');
        nodeHeader.className = 'queue-header';
        nodeHeader.textContent = `${dataCenter.id}`;
        
        const queueStatus = document.createElement('div');
        queueStatus.className = 'queue-status';
        queueStatus.id = `queue-status-${index}`;
        
        if (nodeState.downloadingBlock) {
          queueStatus.textContent = 'Downloading block...';
        } else if (nodeState.queue.length === 0) {
          queueStatus.textContent = 'Queue empty';
        } else {
          queueStatus.textContent = `${nodeState.queue.length} blocks in queue`;
        }
        
        nodeQueue.appendChild(nodeHeader);
        
        // Add queue items with proper color coding by source and displaying block hashes
        nodeState.queue.forEach((blockId, queueIndex) => {
          const queueItem = document.createElement('div');
          
          // Get the block hash for this blockId
          const blockHash = blockHashes[blockId];
          
          // Determine if this is from the hub (HTTPS) or from peers (P2P)
          let isP2P = false;
          let sourceNodeId = 'Hub';
          
          // Check if this is a P2P transfer by looking at pending transfers
          if (isPeerToPeer) {
            // Find if any node is transferring this blockId to current node
            for (let i = 0; i < dataCenters.length; i++) {
              if (i === index) continue; // Skip self
              
              const sourceNode = downloadState.nodesState[i];
              const isTransferring = sourceNode.pendingTransfers.some(
                t => t.blockId === blockId && t.toNode === index
              );
              
              if (isTransferring) {
                isP2P = true;
                sourceNodeId = dataCenters[i].id;
                break;
              }
            }
          }
          
          // Set appropriate class for styling
          queueItem.className = `queue-item ${isP2P ? 'p2p' : 'https'}`;
          if (queueIndex === 0 && nodeState.downloadingBlock) {
            queueItem.classList.add('in-progress');
          }
          
          queueItem.innerHTML = `
            <span>
              ${blockHash} 
              <span class="source-label">${isP2P ? 'P2P' : 'HTTPS'}</span>
            </span>
            <span>${queueIndex === 0 && nodeState.downloadingBlock ? Math.floor(nodeState.blockProgress * 100) + '%' : 'pending'}</span>
          `;
          
          nodeQueue.appendChild(queueItem);
        });
        
        // Add pending P2P transfers to the queue display
        if (isPeerToPeer) {
          // Check all other nodes to see if they're sending blocks to this node
          dataCenters.forEach((_, sourceIndex) => {
            if (sourceIndex === index) return; // Skip self
            
            const sourceState = downloadState.nodesState[sourceIndex];
            const transfersToThisNode = sourceState.pendingTransfers.filter(t => t.toNode === index);
            
            transfersToThisNode.forEach(transfer => {
              const queueItem = document.createElement('div');
              queueItem.className = 'queue-item p2p';
              
              // Get the block hash for this blockId
              const blockHash = blockHashes[transfer.blockId];
              
              queueItem.innerHTML = `
                <span>
                  ${blockHash}
                  <span class="source-label">P2P</span>
                </span>
                <span>${Math.floor(transfer.progress * 100)}%</span>
              `;
              
              nodeQueue.appendChild(queueItem);
            });
          });
        }
        
        // Display current speed with rolling average
        const speedText = document.createElement('div');
        speedText.className = 'queue-status';
        speedText.textContent = `Speed: ${Math.round(nodeState.currentSpeed)} MB/s`;
        
        nodeQueue.appendChild(queueStatus);
        nodeQueue.appendChild(speedText);
        queueContainer.appendChild(nodeQueue);
      });
      
      // Update the legend to include block source types
      updateBlockSourceLegend();
    }

    // Draw network
    function drawNetwork() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw P2P mesh connections first
      if (isPeerToPeer) {
        p2pConnections.forEach(conn => {
          const fromNode = dataCenters[conn.from];
          const toNode = dataCenters[conn.to];
          
          // Calculate active transfers on this connection
          const transfers = downloadState.nodesState[conn.from].pendingTransfers
            .filter(t => t.to === conn.to).length;
          
          const speed = transfers > 0 ? HUNDRED_GBIT_SPEED * transfers : 0;
          const color = speed > 0 ? '#10b981' : 'rgba(16, 185, 129, 0.2)';
          const width = speed > 0 ? 2 : 1;
          
          drawConnection(fromNode, toNode, speed, color, width);
        });
      }

      // Draw connections to hub
      dataCenters.forEach((dc, index) => {
        const nodeState = downloadState.nodesState[index];
        const speed = nodeState.downloadingBlock ? 
          HUB_DOWNLOAD_SPEED / Math.max(1, downloadState.activeDownloads) : 0;
        
        const color = nodeState.downloadingBlock ? 
          (downloadState.activeDownloads > 3 ? '#ef4444' : '#4338ca') : 
          '#cbd5e1';
        
        drawConnection(dc, huggingFaceHub, speed, color, nodeState.downloadingBlock ? 2 : 1);
      });

      // Draw hub
      ctx.beginPath();
      ctx.arc(huggingFaceHub.x, huggingFaceHub.y, 20, 0, Math.PI * 2);
      ctx.fillStyle = huggingFaceHub.color;
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Hub', huggingFaceHub.x, huggingFaceHub.y + 5);

      // Enhanced node visualization
      dataCenters.forEach((dc, index) => {
        const nodeState = downloadState.nodesState[index];
        const netState = networkState.nodes[index];
        
        // Draw node with larger radius
        ctx.beginPath();
        ctx.arc(dc.x, dc.y, 20, 0, Math.PI * 2);
        ctx.fillStyle = dc.color;
        ctx.fill();
        
        // Draw rim indicating activity
        if (nodeState.downloadingBlock || nodeState.pendingTransfers.length > 0) {
          ctx.beginPath();
          ctx.arc(dc.x, dc.y, 22, 0, Math.PI * 2);
          ctx.strokeStyle = nodeState.downloadingBlock ? '#4338ca' : '#10b981';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // Node label
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Node ${index + 1}`, dc.x, dc.y);

        // Draw detailed status
        const statusX = dc.x + 25;
        const statusY = dc.y - 15;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(statusX, statusY, 80, 30);
        ctx.strokeStyle = '#e2e8f0';
        ctx.strokeRect(statusX, statusY, 80, 30);
        
        ctx.fillStyle = 'black';
        ctx.font = '10px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Blocks: ${nodeState.blockIds.size}`, statusX + 5, statusY + 12);
        ctx.fillText(`Speed: ${Math.round(netState.currentSpeed)}MB/s`, statusX + 5, statusY + 24);

        // Progress ring
        if (nodeState.blockIds.size > 0) {
          const progress = nodeState.blockIds.size / TOTAL_BLOCKS;
          ctx.beginPath();
          ctx.arc(dc.x, dc.y, 25, -0.5 * Math.PI, (-0.5 + 2 * progress) * Math.PI);
          ctx.strokeStyle = '#10b981';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      });

      // Draw overall progress bar at top
      const overallProgress = isPeerToPeer 
        ? Math.min(1, downloadState.blockAvailability.filter(available => available).length / TOTAL_BLOCKS)
        : Math.min(1, downloadState.blocksDownloaded / TOTAL_BLOCKS);

      // Make sure we track the proper count regardless of mode
      if (!isPeerToPeer && downloadState.blockAvailability.filter(available => available).length > 0) {
        // When switching from P2P to hub-and-spoke, maintain progress
        const uniqueBlockCount = downloadState.blockAvailability.filter(available => available).length;
        if (uniqueBlockCount > downloadState.blocksDownloaded) {
          downloadState.blocksDownloaded = uniqueBlockCount;
        }
      }

      const barWidth = canvas.width - 100;
      const barHeight = 10;
      const barX = 50;
      const barY = 40; // Adjusted from 10 to give more room at the top
      
      // Background
      ctx.fillStyle = '#e5e7eb';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // Progress
      ctx.fillStyle = '#10b981';
      ctx.fillRect(barX, barY, barWidth * overallProgress, barHeight);
      
      // Label
      ctx.fillStyle = '#1a365d';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      
      // Add block count to the label
      const blockCount = isPeerToPeer ? 
        downloadState.blockAvailability.filter(available => available).length : 
        downloadState.blocksDownloaded;
      
      ctx.fillText(
        `${Math.min(100, Math.floor(overallProgress * 100))}% Complete (${blockCount}/${TOTAL_BLOCKS} blocks)`, 
        canvas.width / 2, 
        barY - 5
      );

      // Draw network statistics
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(10, canvas.height - 60, 200, 50);
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Total Network Traffic: ${Math.round(networkState.nodes.reduce((sum, node) => sum + node.currentSpeed, 0))} MB/s`, 20, canvas.height - 40);
      ctx.fillText(`Active Transfers: ${downloadState.activeDownloads + dataCenters.reduce((sum, _, i) => sum + downloadState.nodesState[i].pendingTransfers.length, 0)}`, 20, canvas.height - 20);
    }

    // Function to update traffic history
    function updateTrafficStats(stats, bytesTransferred, timestamp) {
      // Remove old entries
      stats.trafficHistory = stats.trafficHistory.filter(
        entry => timestamp - entry.time <= ROLLING_WINDOW
      );
      
      // Add new entry
      stats.trafficHistory.push({
        bytes: bytesTransferred,
        time: timestamp
      });
      
      // Calculate rolling average
      const totalBytes = stats.trafficHistory.reduce((sum, entry) => sum + entry.bytes, 0);
      const timeSpan = Math.max(ROLLING_WINDOW, 
        Math.max(...stats.trafficHistory.map(e => e.time)) - 
        Math.min(...stats.trafficHistory.map(e => e.time))
      );
      
      stats.currentSpeed = totalBytes / timeSpan;
    }

    // Function to update speed history and calculate rolling average
    function updateSpeedStats(stats, bytesTransferred, timestamp) {
      // Remove entries older than the rolling window
      stats.speedHistory = stats.speedHistory.filter(
        entry => timestamp - entry.time <= SPEED_ROLLING_WINDOW
      );
      
      // Add new entry
      stats.speedHistory.push({
        bytes: bytesTransferred,
        time: timestamp
      });
      
      // Calculate rolling average speed
      const totalBytes = stats.speedHistory.reduce((sum, entry) => sum + entry.bytes, 0);
      const timeSpan = Math.max(SPEED_ROLLING_WINDOW, 
        stats.speedHistory.length > 0 ? 
        Math.max(...stats.speedHistory.map(e => e.time)) - 
        Math.min(...stats.speedHistory.map(e => e.time)) : 
        1
      );
      
      stats.currentSpeed = totalBytes / timeSpan;
    }

    // Update simulation to use enhanced peer transfers and track speeds properly
    function updateSimulation(deltaTime) {
      let blocksDownloadedThisFrame = 0;
      let blocksTransferredThisFrame = 0;
      downloadState.activeDownloads = 0;

      // Calculate blocks per node - ensure all blocks are accounted for
      const blocksPerNode = Math.ceil(TOTAL_BLOCKS / dataCenters.length);
      
      // Fill queues for nodes that need blocks - check global progress
      const totalBlocksNeeded = isPeerToPeer ? 
        (TOTAL_BLOCKS - downloadState.totalUniqueBlocks) : 
        (TOTAL_BLOCKS - downloadState.blocksDownloaded);
        
      if (totalBlocksNeeded > 0) {
        dataCenters.forEach((dc, index) => {
          const nodeState = downloadState.nodesState[index];
          
          // If queue isn't full and there are still blocks to download globally
          if (nodeState.queue.length < nodeState.queueCapacity) {
            // Calculate how many blocks to add to the queue
            const blocksToAdd = Math.min(
              totalBlocksNeeded, 
              nodeState.queueCapacity - nodeState.queue.length
            );
            
            // Add blocks to the queue
            for (let i = 0; i < blocksToAdd; i++) {
              let newBlockId;
              
              if (isPeerToPeer) {
                // Generate next available block ID that hasn't been assigned yet
                newBlockId = downloadState.totalUniqueBlocks;
                // Make sure we don't exceed total blocks
                if (newBlockId >= TOTAL_BLOCKS) break;
                downloadState.totalUniqueBlocks++; // Increment immediately to prevent duplicates
              } else {
                // In hub-and-spoke, just use the next sequential block ID
                newBlockId = downloadState.blocksDownloaded;
                // Make sure we don't exceed total blocks
                if (newBlockId >= TOTAL_BLOCKS) break;
              }
              
              // Only add the block if it's valid
              if (newBlockId < TOTAL_BLOCKS) {
                nodeState.queue.push(newBlockId);
              }
            }
          }
        });
      }

      // Update each node's download from hub
      dataCenters.forEach((dc, index) => {
        const nodeState = downloadState.nodesState[index];
        
        // If there are items in the queue and not currently downloading
        if (nodeState.queue.length > 0 && !nodeState.downloadingBlock) {
          nodeState.downloadingBlock = true;
          nodeState.blockProgress = 0;
          nodeState.blockStartTime = gameTime;
          downloadState.activeDownloads++;
        } 
        // Continue downloading current block
        else if (nodeState.downloadingBlock) {
          downloadState.activeDownloads++;

          // Calculate effective speed based on congestion
          let effectiveSpeed = HUB_DOWNLOAD_SPEED;
          if (downloadState.activeDownloads > 1) {
            effectiveSpeed = HUB_DOWNLOAD_SPEED / downloadState.activeDownloads;
          }

          // Calculate how much progress to make on this block
          const timeRequired = BLOCK_SIZE / effectiveSpeed;
          const progressDelta = deltaTime / timeRequired;
          nodeState.blockProgress += progressDelta;

          // Check if block download is complete
          if (nodeState.blockProgress >= 1) {
            // Get the block ID from the queue
            const blockId = nodeState.queue.shift();
            
            nodeState.blocksDownloaded += 1;
            blocksDownloadedThisFrame += 1;
            nodeState.downloadingBlock = false;

            // Update global count
            downloadState.blocksDownloaded += 1;
            
            // For P2P mode, track block availability
            if (isPeerToPeer) {
              // Add the block to this node
              nodeState.blockIds.add(blockId);
              downloadState.blockAvailability[blockId] = true;
            }
            
            // If we still have blocks in queue, start downloading next one
            if (nodeState.queue.length > 0) {
              nodeState.downloadingBlock = true;
              nodeState.blockProgress = 0;
              nodeState.blockStartTime = gameTime;
            }
          }

          // Update hub traffic when downloading
          const bytesTransferred = BLOCK_SIZE * progressDelta;
          updateTrafficStats(networkState.hub, bytesTransferred, gameTime);
          updateTrafficStats(networkState.nodes[index], bytesTransferred, gameTime);
          
          // Update node speed history with rolling 3-second window
          updateSpeedStats(nodeState, bytesTransferred, gameTime);
        }
      });

      // Enhanced P2P transfer handling
      if (isPeerToPeer) {
        dataCenters.forEach((dc, nodeIndex) => {
          const nodeState = downloadState.nodesState[nodeIndex];
          
          // Update existing transfers first
          nodeState.pendingTransfers.forEach((transfer, idx) => {
            const timeRequired = BLOCK_SIZE / HUNDRED_GBIT_SPEED;
            const progressDelta = deltaTime / timeRequired;
            transfer.progress += progressDelta;

            if (transfer.progress >= 1) {
              const targetState = downloadState.nodesState[transfer.toNode];
              targetState.blockIds.add(transfer.blockId);
              targetState.blocksDownloaded++;
              blocksTransferredThisFrame++;
              
              // Mark connection as active
              const connIndex = p2pConnections.findIndex(
                conn => (conn.from === nodeIndex && conn.to === transfer.toNode) ||
                       (conn.to === nodeIndex && conn.from === transfer.toNode)
              );
              if (connIndex >= 0) {
                p2pConnections[connIndex].active = true;
                setTimeout(() => { p2pConnections[connIndex].active = false; }, 500);
              }
            }

            // Update traffic stats
            const bytesTransferred = BLOCK_SIZE * progressDelta;
            updateTrafficStats(networkState.nodes[nodeIndex], bytesTransferred, gameTime);
            updateTrafficStats(networkState.nodes[transfer.toNode], bytesTransferred, gameTime);
            
            // Update speed stats for both source and target nodes
            updateSpeedStats(nodeState, bytesTransferred, gameTime);
            updateSpeedStats(downloadState.nodesState[transfer.toNode], bytesTransferred, gameTime);
          });

          // Remove completed transfers
          nodeState.pendingTransfers = nodeState.pendingTransfers.filter(t => t.progress < 1);

          // Try to start new transfers
          if (nodeState.blockIds.size > 0) {
            updatePeerTransfers(nodeIndex, nodeState);
          }
        });
      }

      // Update overall simulation speed calculations using rolling average
      const totalBytesThisFrame = (blocksDownloadedThisFrame + blocksTransferredThisFrame) * BLOCK_SIZE;
      
      // Update global speed history
      updateSpeedStats(downloadState, totalBytesThisFrame, gameTime);
    }

    // Update statistics display
    function updateStatistics() {
      // Calculate actual progress based on downloaded blocks
      const totalProgress = isPeerToPeer
        ? Math.min(1, downloadState.blockAvailability.filter(available => available).length / TOTAL_BLOCKS)
        : Math.min(1, downloadState.blocksDownloaded / TOTAL_BLOCKS);
      
      const progressPct = Math.floor(totalProgress * 100);
      progress.textContent = `${progressPct}% Complete (${isPeerToPeer ? 
        downloadState.blockAvailability.filter(available => available).length : 
        downloadState.blocksDownloaded} / ${TOTAL_BLOCKS} blocks)`;

      // Speed
      speed.textContent = `${Math.floor(downloadState.currentSpeed)} MB/s`;

      // Estimated time
      const remainingBlocks = isPeerToPeer
        ? TOTAL_BLOCKS - downloadState.blockAvailability.filter(available => available).length
        : TOTAL_BLOCKS - downloadState.blocksDownloaded;
      
      const remainingTime = downloadState.currentSpeed > 0
        ? (remainingBlocks * BLOCK_SIZE) / downloadState.currentSpeed
        : Infinity;

      timeEstimate.textContent = remainingTime === Infinity
        ? 'N/A'
        : `${Math.floor(remainingTime / 60)}m ${Math.floor(remainingTime % 60)}s`;

      // Network mode
      networkMode.textContent = isPeerToPeer ? 'Peer-to-Peer' : 'Hub-and-Spoke';

      // Update timer
      timerElement.textContent = `Time: ${Math.floor(gameTime)}s`;
    }

    // Main game loop
    function gameLoop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      // Convert deltaTime from milliseconds to seconds
      const deltaTime = (timestamp - lastTimestamp) / 1000;
      gameTime += deltaTime;

      updateSimulation(deltaTime);
      updateStatistics();
      drawNetwork();
      renderQueues();

      lastTimestamp = timestamp;
      if (isRunning) {
        animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    // Event listeners for simulation controls
    startButton.addEventListener('click', () => {
      if (!isRunning) {
        isRunning = true;
        lastTimestamp = 0; // Reset timestamp for a new run
        animationFrameId = requestAnimationFrame(gameLoop);
      }
    });

    pauseButton.addEventListener('click', () => {
      isRunning = false;
      cancelAnimationFrame(animationFrameId);
    });

    resetButton.addEventListener('click', () => {
      isRunning = false;
      cancelAnimationFrame(animationFrameId);
      resetSimulation();
    });
    
    p2pToggle.addEventListener('change', () => {
      // Save current state before changing mode
      const wasPeerToPeer = isPeerToPeer;
      isPeerToPeer = p2pToggle.checked;
      modeLabel.textContent = isPeerToPeer ? 'On' : 'Off';
      networkMode.textContent = isPeerToPeer ? 'Peer-to-Peer' : 'Hub-and-Spoke';
      
      // Update connections for P2P mode without resetting progress
      initializePeerConnections();
      
      // No need to call resetSimulation() - just update visuals
      updateStatistics();
      renderQueues();
      drawNetwork();
    });

    // Initialize simulation on page load
    resetSimulation();

    // Enhanced P2P transfer initialization
    function initializePeerConnections() {
      p2pConnections.length = 0;
      // Create a fully connected mesh between all nodes
      for (let i = 0; i < dataCenters.length; i++) {
        for (let j = i + 1; j < dataCenters.length; j++) {
          p2pConnections.push({
            from: i,
            to: j,
            active: false,
            maxSpeed: HUNDRED_GBIT_SPEED
          });
        }
      }
    }

    // Update P2P transfer logic to better utilize available bandwidth
    function updatePeerTransfers(nodeIndex, nodeState) {
      const maxConcurrentTransfers = 10; // Increase concurrent transfers from 5 to 10
      const availableSlots = maxConcurrentTransfers - nodeState.pendingTransfers.length;
      
      if (availableSlots <= 0) return;

      // Get nodes sorted by need (fewer blocks = higher priority)
      const needyPeers = dataCenters.map((_, idx) => idx)
        .filter(idx => idx !== nodeIndex)
        .sort((a, b) => {
          const stateA = downloadState.nodesState[a].blockIds.size;
          const stateB = downloadState.nodesState[b].blockIds.size;
          return stateA - stateB; // Simplify sorting to prioritize nodes with fewer blocks
        });

      // Try to fill available transfer slots
      for (const targetIndex of needyPeers) {
        if (nodeState.pendingTransfers.length >= maxConcurrentTransfers) break;
        
        const targetState = downloadState.nodesState[targetIndex];
        
        // Find blocks that this node has but the target doesn't
        const availableBlocks = Array.from(nodeState.blockIds)
          .filter(blockId => !targetState.blockIds.has(blockId));

        // Also check if not already in a transfer
        const blockIdsInTransfer = targetState.pendingTransfers
          .map(transfer => transfer.blockId);
        
        const transferableBlocks = availableBlocks
          .filter(blockId => !blockIdsInTransfer.includes(blockId));
        
        if (transferableBlocks.length > 0) {
          // Start multiple transfers to the same peer if possible
          const transferCount = Math.min(
            transferableBlocks.length,
            maxConcurrentTransfers - nodeState.pendingTransfers.length
          );

          for (let i = 0; i < transferCount; i++) {
            nodeState.pendingTransfers.push({
              blockId: transferableBlocks[i],
              toNode: targetIndex,
              progress: 0,
              transferType: 'p2p',
              speed: HUNDRED_GBIT_SPEED
            });
          }
        }
      }
    }

    // Add speed indicators for active connections
    function drawConnection(fromNode, toNode, speed, color, width) {
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();

      // Draw speed indicator
      if (speed > 0) {
        const midX = (fromNode.x + toNode.x) / 2;
        const midY = (fromNode.y + toNode.y) / 2;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(midX - 30, midY - 10, 60, 20);
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(speed)} MB/s`, midX, midY + 4);
      }
    }

    // Add function to update the legend with block source types
    function updateBlockSourceLegend() {
      // Check if we already have the new legend items
      const legendContainer = document.querySelector('.legend');
      const existingHttpsItem = Array.from(legendContainer.querySelectorAll('.legend-item'))
        .find(item => item.textContent.includes('HTTPS Block'));
      
      if (!existingHttpsItem) {
        // Add HTTPS block legend item
        const httpsItem = document.createElement('div');
        httpsItem.className = 'legend-item';
        httpsItem.innerHTML = `
          <div class="legend-color" style="background-color: #f59e0b;"></div>
          <span>HTTPS Block</span>
        `;
        legendContainer.appendChild(httpsItem);
        
        // Add P2P block legend item
        const p2pItem = document.createElement('div');
        p2pItem.className = 'legend-item';
        p2pItem.innerHTML = `
          <div class="legend-color" style="background-color: #10b981;"></div>
          <span>P2P Block</span>
        `;
        legendContainer.appendChild(p2pItem);
      }
    }
  </script>
</body>
</html>