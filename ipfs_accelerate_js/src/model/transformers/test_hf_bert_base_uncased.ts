// FI: any;
 * Convert: any;
 * Conversi: any;
 * Th: any;
 * Conversi: any;
 */;

// WebG: any;
import {HardwareBackend} import * as module} import { {  * a: a: any;"";" } from ""{*";"
impo: any;
impo: any;
import ${$1} fr: any;

// Hardwa: any;
HAS_CUDA: any: any: any = torch.cuda.is_available() if ((((((hasattr(torch) { any, "cuda") { else { fals) { an) { an: any;"
HAS_MPS) { any) { any = hasattr(torch: any, "mps") && torch.mps.is_available() if (((((hasattr(torch) { any, "mps") { else { fals) { an) { an: any;"
HAS_ROCM) { any) { any = hasattr(torch: any, "_C") && hasattr(torch._C, "_rocm_version") if (((((hasattr(torch) { any, "_C") { else { fals) { an) { an: any;"
;
class TestBertbaseuncased extends unittest.TestCase) {
  /** Tes) { an: any;


  
  $1($2) {this.model_name = "bert-base-uncased";"
    this.tokenizer = n: any;


    this.model = n: any;

};
  $1($2) {
    /** Te: any;


    // Sk: any;


    if (((($1) {
      this) { a) { an: any;


    else if (((($1) {this.skipTest("MPS !available")} else if (($1) {this.skipTest("ROCm !available")}"
    // Load) { a) { an: any;


    }
    this.tokenizer = AutoTokenize) { an: any;


    }
    this.model = AutoMod: any;


    
  }
    // Te: any;
    inputs) { any) { any) { any) { any) { any: any: any = this.tokenizer("Hello, world!", return_tensors: any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    ;
  $1($2) {
    /** Te: any;
    // Sk: any;
    if (((($1) {this.skipTest("CUDA !available")} else if (($1) {"
      this) { an) { an: any;
    else if (((($1) {this.skipTest("ROCm !available")}"
    // Load) { an) { an: any;
    }
    this.tokenizer = AutoTokenize) { an: any;
    }
    this.model = AutoMod: any;
    
  }
    // Te: any;
    inputs) { any) { any = this.tokenizer("Hello, world!", return_tensors) { any) { any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    ;
  $1($2) {
    /** Te: any;
    // Sk: any;
    if (((($1) {this.skipTest("CUDA !available")} else if (($1) {"
      this) { an) { an: any;
    else if (((($1) {this.skipTest("ROCm !available")}"
    // Load) { an) { an: any;
    }
    this.tokenizer = AutoTokenize) { an: any;
    }
    this.model = AutoMod: any;
    
  }
    // Te: any;
    inputs) { any) { any = this.tokenizer("Hello, world!", return_tensors) { any) { any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    ;
  $1($2) {
    /** Te: any;
    // Sk: any;
    if (((($1) {this.skipTest("CUDA !available")} else if (($1) {"
      this) { an) { an: any;
    else if (((($1) {this.skipTest("ROCm !available")}"
    // Load) { an) { an: any;
    }
    this.tokenizer = AutoTokenize) { an: any;
    }
    this.model = AutoMod: any;
    
  }
    // Te: any;
    inputs) { any) { any = this.tokenizer("Hello, world!", return_tensors) { any) { any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    ;
  $1($2) {
    /** Te: any;
    // Sk: any;
    if (((($1) {this.skipTest("CUDA !available")} else if (($1) {"
      this) { an) { an: any;
    else if (((($1) {this.skipTest("ROCm !available")}"
    // Load) { an) { an: any;
    }
    this.tokenizer = AutoTokenize) { an: any;
    }
    this.model = AutoMod: any;
    
  }
    // Te: any;
    inputs) { any) { any = this.tokenizer("Hello, world!", return_tensors) { any) { any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    ;
  $1($2) {
    /** Te: any;
    // Sk: any;
    if (((($1) {this.skipTest("CUDA !available")} else if (($1) {"
      this) { an) { an: any;
    else if (((($1) {this.skipTest("ROCm !available")}"
    // Load) { an) { an: any;
    }
    this.tokenizer = AutoTokenize) { an: any;
    }
    this.model = AutoMod: any;
    
  }
    // Te: any;
    inputs) { any) { any = this.tokenizer("Hello, world!", return_tensors) { any) { any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    ;
  $1($2) {
    /** Te: any;
    // Sk: any;
    if (((($1) {this.skipTest("CUDA !available")} else if (($1) {"
      this) { an) { an: any;
    else if (((($1) {this.skipTest("ROCm !available")}"
    // Load) { an) { an: any;
    }
    this.tokenizer = AutoTokenize) { an: any;
    }
    this.model = AutoMod: any;
    
  }
    // Te: any;
    inputs) { any) { any = this.tokenizer("Hello, world!", return_tensors) { any) { any: any: any: any: any: any = "pt");"
    outputs: any: any: any = th: any;
    
    // Veri: any;
    th: any;
    conso: any;
    
;
if (((($1) {;;
  unittest) { an) { an) { an: any;
;